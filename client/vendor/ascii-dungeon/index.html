
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ASCII Dungeon Renderer with Global Illumination</title>
  <link rel="stylesheet" href="./css/mdxish.css">
  <meta charset="UTF-8">
  <meta name="description"
        content="An ASCII dungeon renderer with WebGL-based global illumination">
  <meta name="og:description" content="A globally illuminated ASCII dungeon renderer">
  <meta name="twitter:card" content="summary_large_image">
  <meta property="og:title" content="ASCII Dungeon Renderer with GI">
  <meta property="og:type" content="website">
  <meta property="og:image" content="https://jason.today/img/ascii-dungeon.png">
  <style>
    button {
      border: none;
      cursor: pointer;
    }

    .color {
      max-width: 20px;
      width: 20px;
      height: 20px;
      position: relative;
    }

    canvas {
      image-rendering: auto;
      cursor: grab;
    }

    canvas:active {
      cursor: grabbing;
    }

    #viewportControls button {
      padding: 5px 10px;
      cursor: pointer;
      background-color: #444;
      color: #fff;
      border: none;
      border-radius: 4px;
    }

    #viewportControls button:hover {
      background-color: #555;
    }

    #viewportControls button:active {
      background-color: #333;
    }

    .iconButton {
      margin-left: -1px;
      padding: 0;
      width: 24px;
      height: 24px;
      padding-top: 4px;
    }

    .erase {
      position: absolute;
      top: 2px;
      left: 1px;
    }

    .arrow {
      border: none;
      position: absolute;
      top: 0;
      left: -17px;
      cursor: auto;
      color: var(--article-text-color);
    }

    .hidden {
      display: none;
    }

    textarea {
      width: 100%;
      height: 200px;
      margin-bottom: 10px;
      font-family: monospace;
    }

    #dungeonInput {
      margin-top: 20px;
    }
  </style>
</head>
<body>

<div id="content">
  <p><a href="https://jason.today">jason.today</a></p>
  <h1 id="ascii-dungeon-gi">ASCII Dungeon Renderer with Global Illumination</h1>
  <p>A real-time renderer for ASCII dungeons with global illumination, using radiance cascades.</p>
  <p>Pan and zoom in the canvas using mouse or touch.</p>

  <script src="./ascii-dungeon/interactivity-setup.js"></script>
  <span id="radiance-cascades-enabled"></span>
  <span id="falling-sand-enabled"></span>

  <div id="bigger-canvas"></div>

  <div id="falloff-slider-container"></div>

  <details style="cursor: pointer">
    <summary>Rendering Controls</summary>

    <div style="align-items: center; gap: 4px;">
      <input type="checkbox" id="bilinear-fix" checked>
      <label for="bilinear-fix">Bilinear Fix</label>
    </div>

    <div style="display: flex; align-items: center; gap: 4px">
      <input type="checkbox" id="enable-nearest">
      <label for="enable-nearest">Nearest</label>
    </div>

    <div id="radius-slider-container">
    </div>

    <div style="display: flex; align-items: center; gap: 8px">
      Sun Angle
      <input id="rc-sun-angle-slider" class="slider" type="range" min="0" max="6.2" step="0.1" value="2.0"/>
    </div>
  </details>
  <br/>

  <div id="rc-canvas"></div>

  <div id="viewportControls" style="display: flex; align-items: center; gap: 20px; margin-bottom: 10px;">
    <div style="display: flex; gap: 10px;">
      <button id="resetView" title="Reset View">Reset View</button>
    </div>
    <div>
      <span id="zoomLevel">Zoom: 1.0x</span>
    </div>
  </div>

  <div id="dungeonInput">
    <h3>Edit Dungeon Map</h3>
    <p>Modify the text and colors below and it'll update in real time!</p>
    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
      <div>
        <label for="canvasWidth">Width:</label>
        <input type="number" id="canvasWidth" min="100" max="1024">
      </div>
      <div>
        <label for="canvasHeight">Height:</label>
        <input type="number" id="canvasHeight" min="100" max="1024">
      </div>
    </div>
    <textarea id="dungeonMapText">#############################################################################
#,,,,,,,,,###~~~~~~~###########,,,,,,,,,,,,,,,###########=================##
#,,,,,,,,,,##~~~~~~~#...#ooooo#,,,,,,,^,,,,,,,#...#...#+=======+========+.#
#,,^,,,,^,,,##~~≈~~~+...#o≈≈≈o#,,,,╔══╗,,,╔══╗+...+...+=======.========+..#
#,,,,,,,,,,,##~≈≈≈~~#...#o≈☠≈o+,,,╔╝..╚═══╝..╚╗#...########+==+========+..#
#####+#+#,,,,#~~~~~~#...#o≈≈≈o#,,,║...........]#...#∞....∞#=============..#
#...###!!#,,,########+###ooooo#,,,║...^...^...║#...#......##########+######
#..&..+!!#,,,#▲...┌────────┐..#,,,╚═══════════╝#...#..☠☠☠☠☠☠..☠#...#☼...☼#
#...###!!#,,,#....│..@.....│T.+,,,####+#########...#.*.*.*.*.*..#...+.....#
##+####+##,,,#....└────────┘..#~≈≈#!!!#≡≡≡≡≡≡≡≡#...##################+#####
#≈≈≈≈≈#,,,,,^#.............D.#~≈≈+!!!+≡≡≡≡≡≡≡≡+...#∞...∞#☠...☠#.....#...⚔#
#≈≈≈≈≈#,,,,,,#...⚱...⚱...⚱...#~≈≈#!!!#≡≡≡≡☠≡≡≡#...#.....+.....+.☠...+...⚔#
#~~~~~#,,,,,,#...............###~≈#!!!#≡≡≡≡≡≡≡≡#...#.....#.....#.....#...⚔#
#~~~~~#,,,,,,#........*......#...~#####+≡≡≡≡≡≡≡#...##################⚰⚰⚰⚰#
#~~~~~#,,,,,,#..?............#....~~~~~~≡≡≡≡≡≡≡≡#..∞####+#.....#...........#
######+############+####+#####...~~~~~~≡≡≡≡≡≡≡≡≡+....§...+..$..#...........#
#§....┌─┐....#%..$#☼...#⚱...#...~~~~~≡≡≡≡≡≡≡≡≡≡#....#####.....#.⚰⚰⚰⚰⚰⚰⚰⚰.#
#.....│ │....#....#....#....#....~~~~≡≡≡≡≡≡≡≡≡≡≡#............☠#.⚰........⚰.#
#..τ..└─┘....+....+....#..%.#.....~~~≡≡≡≡≡≡≡≡≡≡≡########+#####+.⚰.☠⚱☠⚱☠⚱.⚰.#
#...............#....#..../.#......~~≡≡≡≡≡≡≡≡≡≡≡#.*...#.∞...∞#...⚰........⚰.#
#∞...∞#.........#...*#....∞#.......~≡≡≡≡≡≡≡≡≡≡≡+.*...+.*.*.*#...⚰⚰⚰⚰⚰⚰⚰⚰.#
###############################......≡≡≡≡≡≡≡≡≡≡≡#.*...#.*.*.*#...............#
#▓░░░░#███████#░░░░░#▓▓▓▓▓▓▓▓#.....≡≡≡≡≡≡≡≡≡≡≡≡################............⚔#
#▓░▲░░#█.....█#░...░#▓..☠..▓▓+....≡≡≡≡≡≡≡≡≡≡≡≡≡#~~~~~~~~~~~~~~~~#══════════⚔#
#▓░░░░#█..%..█#░...░#▓.....▓▓#...≡≡≡≡≡≡≡≡≡≡≡≡≡≡+~~~~~~~~~~~~~~~~+║☠☠☠⚰☠☠☠║⚔#
#▓░░░░+█.....█+░...░+▓..⚔..▓▓#..≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡#~~~~~~~~~~~~~~~~#║☠⚰☠⚰☠⚰☠║.#
#▓░░░░#███████#░...░#▓▓▓▓▓▓▓▓#.≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡#~~~~~~~~~~~~~~~~#║☠☠☠⚰☠☠☠║.#
#▓▓▓▓▓#........#░░░░░#.......≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡#~~~~~~~~~~~~~~~~#══════════.#
########################........≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡#~~~~~~~~~~~~~~~~#............#
#☥.☥.☥.☥.☥.☥.☥.☥.☥.☥#.........≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡#~~~~~~~~~~~~~~~~#............#
#.....................#..........≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡#~~~~~~~~~~~~~~~~###+########
#☥.☥.☥.☥.☥.☥.☥.☥.☥.☥#...........≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡#☯.☯.☯.☯.☯.☯.☯.☯.#
#.....................#............≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡+.................#
#☥.☥.☥.☥.☥.☥.☥.☥.☥.☥#..............≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡#☯.☯.☯.☯.☯.☯.☯.☯.#
#.....................#................≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡#+#############
#############################################################################</textarea>

    <h3>Character Color Map</h3>
    <p>JSON mapping characters to RGB color arrays (e.g. {"#": [0.6, 0.6, 0.6], "@": [1.0, 0.9, 0.0]})</p>
    <textarea id="characterColorMapText">{
  "#": [0.12, 0.12, 0.12],
  ".": [0.09, 0.09, 0.09],
  ",": [0.14, 0.28, 0.14],
  "~": [0.0, 0.35, 0.7],
  "≈": [0.0, 0.45, 0.65],
  "≡": [0.0, 0.3, 0.55],
  "@": [1.0, 0.9, 0.0],
  "D": [0.9, 0.0, 0.0],
  "^": [0.5, 0.25, 0.0],
  "+": [0.6, 0.45, 0.25],
  "!": [0.0, 0.8, 0.0],
  "&": [0.65, 0.65, 0.65],
  "T": [0.4, 0.2, 0.0],
  "*": [0.9, 0.9, 0.4],
  "?": [0.7, 0.3, 0.7],
  "▲": [0.8, 0.0, 0.0],
  "┌": [0.35, 0.35, 0.35],
  "─": [0.35, 0.35, 0.35],
  "┐": [0.35, 0.35, 0.35],
  "│": [0.35, 0.35, 0.35],
  "└": [0.35, 0.35, 0.35],
  "┘": [0.35, 0.35, 0.35],
  "§": [0.4, 0.0, 0.4],
  "τ": [0.6, 0.6, 0.0],
  "∞": [0.0, 0.4, 0.4],
  "$": [0.95, 0.8, 0.0],
  "%": [0.6, 0.3, 0.0],
  "/": [0.65, 0.65, 0.65],
  "☼": [0.95, 0.6, 0.0],
  "o": [0.08, 0.08, 0.08],
  "░": [0.2, 0.2, 0.2],
  "▓": [0.15, 0.15, 0.15],
  "█": [0.1, 0.1, 0.1],
  "⚔": [0.75, 0.75, 0.75],
  "⚱": [0.5, 0.3, 0.2],
  "⚰": [0.3, 0.2, 0.1],
  "☠": [0.7, 0.0, 0.0],
  "☥": [0.7, 0.7, 0.0],
  "☯": [0.8, 0.0, 0.8],
  "╔": [0.25, 0.25, 0.25],
  "╗": [0.25, 0.25, 0.25],
  "╝": [0.25, 0.25, 0.25],
  "╚": [0.25, 0.25, 0.25],
  "═": [0.25, 0.25, 0.25],
  "║": [0.25, 0.25, 0.25],
  "]": [0.25, 0.25, 0.25],
  "=": [0.3, 0.3, 0.3]
}</textarea>

    <h3>Position Color Map</h3>
    <p>JSON mapping x,y coordinates to RGB color arrays (e.g. {"5,3": [1.0, 0.0, 0.0], "7,10": [0.0, 1.0, 0.0]})</p>
    <textarea id="positionColorMapText">{
  "10,8": [1.0, 0.9, 0.0],
  "19,10": [1.0, 0.0, 0.0],
  "38,10": [0.0, 0.7, 0.0],
  "23,4": [0.0, 0.7, 1.0],
  "56,23": [0.9, 0.0, 0.0],
  "7,17": [0.5, 0.0, 0.5],
  "35,22": [1.0, 0.5, 0.0],
  "60,8": [1.0, 0.7, 0.0],
  "53,19": [0.0, 0.8, 0.8],
  "30,5": [0.0, 0.0, 0.8],
  "47,14": [0.8, 0.8, 0.0],
  "16,13": [1.0, 1.0, 0.5],
  "71,26": [0.7, 0.0, 0.7],
  "25,30": [0.6, 0.6, 0.0],
  "63,31": [0.8, 0.0, 0.8]
}</textarea>
  </div>

  <script src="./ascii-dungeon/ascii-texture.js"></script>
  <script src="./ascii-dungeon/ascii-gi-helpers.js"></script>
  <script src="./ascii-dungeon/ascii-gi.js"></script>
  <script>
    const urlParams = new URLSearchParams(window.location.search);
    const dp = urlParams.get('pixelRatio') ?? 1.0;
    const rcScale = urlParams.get('rcScale') ?? dp;

    // Set initial dimensions
    let width = parseInt(urlParams.get('width')) || (isMobile ? 300 : 512);
    let height = parseInt(urlParams.get('height')) || (isMobile ? 400 : 512);

    // Initialize canvas and event handlers when DOM content is loaded
    document.addEventListener('DOMContentLoaded', function() {
      // Set input field values
      document.getElementById('canvasWidth').value = width;
      document.getElementById('canvasHeight').value = height;

      // Initialize renderer
      initializeRenderer();

      // Set up event listeners
      document.getElementById('dungeonMapText').addEventListener('input', function(event) {
        window.radianceCascades.setDungeonMap(event.target.value);
      });

      document.getElementById('characterColorMapText').addEventListener('input', function(event) {
        window.radianceCascades.surface.setCharacterColorMap(event.target.value);
      });

      document.getElementById('positionColorMapText').addEventListener('input', function(event) {
        window.radianceCascades.surface.setPositionColorMap(event.target.value);
      });

      document.getElementById('canvasWidth').addEventListener('input', function(event) {
        width = Math.max(100, parseInt(event.target.value) || width);
        updateCanvasSize();
      });

      document.getElementById('canvasHeight').addEventListener('input', function(event) {
        height = Math.max(100, parseInt(event.target.value) || height);
        updateCanvasSize();
      });

      document.getElementById('resetView').addEventListener('click', function() {
        window.radianceCascades.resetCamera();
        updateZoomDisplay();
      });

      // Set up mouse interaction for panning and zooming
      const canvas = window.radianceCascades.canvas;

      // Mouse controls
      canvas.addEventListener('mousedown', function(e) {
        window.radianceCascades.camera.isDragging = true;
        window.radianceCascades.camera.lastMouseX = e.clientX;
        window.radianceCascades.camera.lastMouseY = e.clientY;
      });

      canvas.addEventListener('mousemove', function(e) {
        if (!window.radianceCascades.camera.isDragging) return;

        const deltaX = e.clientX - window.radianceCascades.camera.lastMouseX;
        const deltaY = e.clientY - window.radianceCascades.camera.lastMouseY;

        const zoomFactor = 1.0 / Math.sqrt(window.radianceCascades.camera.zoomLevel);
        window.radianceCascades.panCamera(-deltaX * zoomFactor, -deltaY * zoomFactor);

        window.radianceCascades.camera.lastMouseX = e.clientX;
        window.radianceCascades.camera.lastMouseY = e.clientY;
      });

      canvas.addEventListener('mouseup', function() {
        window.radianceCascades.camera.isDragging = false;
      });

      canvas.addEventListener('mouseleave', function() {
        window.radianceCascades.camera.isDragging = false;
      });

      canvas.addEventListener('wheel', function(e) {
        e.preventDefault();

        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;

        const factor = e.deltaY > 0 ? 0.9 : 1.1; // Zoom out with positive deltaY
        window.radianceCascades.zoomCamera(factor, x, y);

        updateZoomDisplay();
      });

      // Touch controls
      let lastTouchDistance = 0;

      canvas.addEventListener('touchstart', function(e) {
        e.preventDefault(); // Prevent webpage scrolling

        if (e.touches.length === 1) {
          // Single touch for panning
          window.radianceCascades.camera.isDragging = true;
          window.radianceCascades.camera.lastMouseX = e.touches[0].clientX;
          window.radianceCascades.camera.lastMouseY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
          // Two touches for pinch zoom
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
        }
      }, { passive: false });

      canvas.addEventListener('touchmove', function(e) {
        e.preventDefault(); // Prevent webpage scrolling

        if (e.touches.length === 1 && window.radianceCascades.camera.isDragging) {
          // Handle panning with one finger
          const deltaX = e.touches[0].clientX - window.radianceCascades.camera.lastMouseX;
          const deltaY = e.touches[0].clientY - window.radianceCascades.camera.lastMouseY;

          const zoomFactor = 1.0 / Math.sqrt(window.radianceCascades.camera.zoomLevel);
          window.radianceCascades.panCamera(-deltaX * zoomFactor, -deltaY * zoomFactor);

          window.radianceCascades.camera.lastMouseX = e.touches[0].clientX;
          window.radianceCascades.camera.lastMouseY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
          // Handle pinch zoom with two fingers
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (lastTouchDistance > 0) {
            // Calculate zoom factor based on pinch distance change
            const factor = distance / lastTouchDistance;

            // Get center point between the two touches for zoom origin
            const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
            const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

            // Convert to normalized coordinates (0-1)
            const rect = canvas.getBoundingClientRect();
            const x = (centerX - rect.left) / rect.width;
            const y = (centerY - rect.top) / rect.height;

            // Apply zoom (only if the change is significant enough)
            if (Math.abs(factor - 1.0) > 0.01) {
              window.radianceCascades.zoomCamera(factor, x, y);
              updateZoomDisplay();
            }
          }

          lastTouchDistance = distance;
        }
      }, { passive: false });

      canvas.addEventListener('touchend', function(e) {
        // Reset if all fingers are lifted
        if (e.touches.length === 0) {
          window.radianceCascades.camera.isDragging = false;
          lastTouchDistance = 0;
        } else if (e.touches.length === 1) {
          // If going from 2 fingers to 1, reset touch distance but keep tracking for pan
          lastTouchDistance = 0;
          window.radianceCascades.camera.lastMouseX = e.touches[0].clientX;
          window.radianceCascades.camera.lastMouseY = e.touches[0].clientY;
        }
      });
    });

    function updateZoomDisplay() {
      const zoomLevel = window.radianceCascades.camera.zoomLevel.toFixed(1);
      document.getElementById('zoomLevel').textContent = `Zoom: ${zoomLevel}x`;
    }

    function initializeRenderer() {
      window.radianceCascades = new RC({
        id: "rc-canvas",
        width: dp * width / rcScale,
        height: dp * height / rcScale,
        dpr: rcScale,
        canvasScale: rcScale / dp,
      });

      // Apply initial viewport size to the surface
      if (window.radianceCascades.surface) {
        window.radianceCascades.dungeonUniforms.viewportSize = [width, height];
        window.radianceCascades.updateGridSize();
      }

      // Initialize with current dungeon map and color maps
      window.radianceCascades.setDungeonMap(document.getElementById('dungeonMapText').value);

      // Set initial color maps
      window.radianceCascades.surface.setCharacterColorMap(document.getElementById('characterColorMapText').value);
      window.radianceCascades.surface.setPositionColorMap(document.getElementById('positionColorMapText').value);
    }

    function updateCanvasSize() {
      if (window.radianceCascades && window.radianceCascades.surface) {
        width = Math.max(100, width);
        height = Math.max(100, height);

        // Store old dimensions for calculating scaling ratios
        const oldWidth = window.radianceCascades.width;
        const oldHeight = window.radianceCascades.height;

        // Update dimensions for the renderer
        window.radianceCascades.width = dp * width / rcScale;
        window.radianceCascades.height = dp * height / rcScale;
        window.radianceCascades.surface.width = dp * width / rcScale;
        window.radianceCascades.surface.height = dp * height / rcScale;

        // Update canvas dimensions
        window.radianceCascades.canvas.width = dp * width;
        window.radianceCascades.canvas.height = dp * height;
        window.radianceCascades.canvas.style.width = `${width}px`;
        window.radianceCascades.canvas.style.height = `${height}px`;

        // Update the viewport size in shader uniforms
        window.radianceCascades.dungeonUniforms.viewportSize = [width, height];

        // Scale camera position to maintain view center
        // This ensures changing dimensions adjusts view like panning/zooming
        const xRatio = window.radianceCascades.width / oldWidth;
        const yRatio = window.radianceCascades.height / oldHeight;
        window.radianceCascades.camera.x *= xRatio;
        window.radianceCascades.camera.y *= yRatio;

        // Update all resolution-dependent parameters for global illumination
        window.radianceCascades.renderWidth = window.radianceCascades.width;
        window.radianceCascades.renderHeight = window.radianceCascades.height;

        // Recalculate radiance cascade parameters
        const angularSize = Math.sqrt(
          window.radianceCascades.renderWidth * window.radianceCascades.renderWidth +
          window.radianceCascades.renderHeight * window.radianceCascades.renderHeight
        );
        window.radianceCascades.radianceCascades = Math.ceil(
          Math.log(angularSize) / Math.log(4)
        ) + 1.0;

        window.radianceCascades.radianceWidth = Math.floor(
          window.radianceCascades.renderWidth / window.radianceCascades.basePixelsBetweenProbes
        );
        window.radianceCascades.radianceHeight = Math.floor(
          window.radianceCascades.renderHeight / window.radianceCascades.basePixelsBetweenProbes
        );

        // Update GI shader uniforms
        if (window.radianceCascades.rcUniforms) {
          window.radianceCascades.rcUniforms.resolution = [window.radianceCascades.width, window.radianceCascades.height];
          window.radianceCascades.rcUniforms.cascadeExtent = [window.radianceCascades.radianceWidth, window.radianceCascades.radianceHeight];
          window.radianceCascades.rcUniforms.cascadeCount = window.radianceCascades.radianceCascades;
        }

        // Update JFA and DistanceField shader uniforms
        if (window.radianceCascades.jfaUniforms) {
          window.radianceCascades.jfaUniforms.resolution = [window.radianceCascades.width, window.radianceCascades.height];
          window.radianceCascades.jfaUniforms.oneOverSize = [1.0 / window.radianceCascades.width, 1.0 / window.radianceCascades.height];
        }

        if (window.radianceCascades.dfUniforms) {
          window.radianceCascades.dfUniforms.resolution = [window.radianceCascades.width, window.radianceCascades.height];
        }

        if (window.radianceCascades.seedUniforms) {
          window.radianceCascades.seedUniforms.resolution = [window.radianceCascades.width, window.radianceCascades.height];
        }

        // Recreate all render targets with new dimensions
        // Main render targets
        for (let i = 0; i < window.radianceCascades.renderTargets.length; i++) {
          window.radianceCascades.renderTargets[i] = window.radianceCascades.renderer.createRenderTarget(
            window.radianceCascades.width,
            window.radianceCascades.height,
            {
              minFilter: window.radianceCascades.gl.NEAREST_MIPMAP_NEAREST,
              magFilter: window.radianceCascades.gl.NEAREST,
              internalFormat: window.radianceCascades.gl.RGBA,
              format: window.radianceCascades.gl.RGBA,
              type: window.radianceCascades.gl.UNSIGNED_BYTE
            }
          );
        }

        // High resolution render targets
        if (window.radianceCascades.renderTargetsHigh) {
          const scaling = window.radianceCascades.scaling || 1;
          for (let i = 0; i < window.radianceCascades.renderTargetsHigh.length; i++) {
            window.radianceCascades.renderTargetsHigh[i] = window.radianceCascades.renderer.createRenderTarget(
              window.radianceCascades.width * scaling,
              window.radianceCascades.height * scaling,
              {
                minFilter: window.radianceCascades.gl.NEAREST_MIPMAP_NEAREST,
                magFilter: window.radianceCascades.gl.NEAREST,
                internalFormat: window.radianceCascades.gl.RGBA,
                format: window.radianceCascades.gl.RGBA,
                type: window.radianceCascades.gl.UNSIGNED_BYTE
              }
            );
          }
        }

        // JFA render targets
        if (window.radianceCascades.jfaRenderTargets) {
          for (let i = 0; i < window.radianceCascades.jfaRenderTargets.length; i++) {
            let rtConfig = {
              minFilter: window.radianceCascades.gl.NEAREST,
              magFilter: window.radianceCascades.gl.NEAREST
            };

            // Check if width/height is large enough to use high precision formats
            if (window.radianceCascades.width > 1024 || window.radianceCascades.height > 1024) {
              rtConfig.internalFormat = window.radianceCascades.gl.RG32F;
              rtConfig.format = window.radianceCascades.gl.RG;
              rtConfig.type = window.radianceCascades.gl.FLOAT;
            } else {
              rtConfig.internalFormat = window.radianceCascades.gl.RG16F;
              rtConfig.format = window.radianceCascades.gl.RG;
              rtConfig.type = window.radianceCascades.gl.HALF_FLOAT;
            }

            window.radianceCascades.jfaRenderTargets[i] = window.radianceCascades.renderer.createRenderTarget(
              window.radianceCascades.width,
              window.radianceCascades.height,
              rtConfig
            );
          }
        }

        // Seed render targets (same format as JFA)
        if (window.radianceCascades.seedRenderTargets) {
          for (let i = 0; i < window.radianceCascades.seedRenderTargets.length; i++) {
            let rtConfig = {
              minFilter: window.radianceCascades.gl.NEAREST,
              magFilter: window.radianceCascades.gl.NEAREST
            };

            if (window.radianceCascades.width > 1024 || window.radianceCascades.height > 1024) {
              rtConfig.internalFormat = window.radianceCascades.gl.RG32F;
              rtConfig.format = window.radianceCascades.gl.RG;
              rtConfig.type = window.radianceCascades.gl.FLOAT;
            } else {
              rtConfig.internalFormat = window.radianceCascades.gl.RG16F;
              rtConfig.format = window.radianceCascades.gl.RG;
              rtConfig.type = window.radianceCascades.gl.HALF_FLOAT;
            }

            window.radianceCascades.seedRenderTargets[i] = window.radianceCascades.renderer.createRenderTarget(
              window.radianceCascades.width,
              window.radianceCascades.height,
              rtConfig
            );
          }
        }

        // Distance field render targets
        if (window.radianceCascades.dfRenderTargets) {
          for (let i = 0; i < window.radianceCascades.dfRenderTargets.length; i++) {
            window.radianceCascades.dfRenderTargets[i] = window.radianceCascades.renderer.createRenderTarget(
              window.radianceCascades.width,
              window.radianceCascades.height,
              {
                minFilter: window.radianceCascades.gl.NEAREST,
                magFilter: window.radianceCascades.gl.NEAREST,
                internalFormat: window.radianceCascades.gl.R16F,
                format: window.radianceCascades.gl.RED,
                type: window.radianceCascades.gl.HALF_FLOAT
              }
            );
          }
        }

        // RC render targets for global illumination
        if (window.radianceCascades.rcRenderTargets) {
          for (let i = 0; i < window.radianceCascades.rcRenderTargets.length; i++) {
            window.radianceCascades.rcRenderTargets[i] = window.radianceCascades.renderer.createRenderTarget(
              window.radianceCascades.width,
              window.radianceCascades.height,
              {
                minFilter: window.radianceCascades.gl.LINEAR_MIPMAP_LINEAR,
                magFilter: window.radianceCascades.gl.LINEAR,
                internalFormat: window.radianceCascades.gl.R11F_G11F_B10F,
                format: window.radianceCascades.gl.RGB,
                type: window.radianceCascades.gl.HALF_FLOAT
              }
            );
          }
        }

        // Overlay render targets
        if (window.radianceCascades.overlayRenderTargets) {
          for (let i = 0; i < window.radianceCascades.overlayRenderTargets.length; i++) {
            window.radianceCascades.overlayRenderTargets[i] = window.radianceCascades.renderer.createRenderTarget(
              window.radianceCascades.width,
              window.radianceCascades.height,
              {
                minFilter: window.radianceCascades.gl.LINEAR,
                magFilter: window.radianceCascades.gl.LINEAR
              }
            );
          }
        }

        // Update camera uniforms with the new position
        window.radianceCascades.updateCameraUniforms();

        // Recalculate grid size and render
        window.radianceCascades.updateGridSize();

        // Force a full render pass with the new dimensions
        window.radianceCascades.frame = 0;
        window.radianceCascades.renderPass();
      }
    }
  </script>

  <p>Reference:</p>
  <p><a href="https://jason.today/gi">Building real-time global illumination</a></p>
</div>
</body>
</html>
